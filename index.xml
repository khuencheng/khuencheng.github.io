<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>khuencheng 的个人博客</title><link>https://khuencheng.github.io/</link><description>Recent content on khuencheng 的个人博客</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Sat, 30 Dec 2023 23:11:34 +0800</lastBuildDate><atom:link href="https://khuencheng.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Streamlining Real-Time Data: Master HTML5 SSE like ChatGPT</title><link>https://khuencheng.github.io/posts/html5-sse/</link><pubDate>Sat, 30 Dec 2023 23:11:34 +0800</pubDate><guid>https://khuencheng.github.io/posts/html5-sse/</guid><description>Introduction In the age of real-time interactivity where services like ChatGPT excel, it&amp;rsquo;s crucial for developers to leverage technologies that allow for seamless data streaming in their applications. This article will delve into the world of HTML5 Server-Sent Events (SSE), a powerful tool akin to the technology behind conversational AI interfaces. Similar to how ChatGPT streams data to provide instant responses, SSE enables web browsers to receive updates from a server without the need for repetitive client-side requests. Whether you&amp;rsquo;re building a chat application, a live notification system, or any service requiring real-time data flow, this guide will equip you with the knowledge to implement SSE efficiently in your applications, ensuring a responsive and engaging user experience.</description></item><item><title>如何成为开源项目的贡献者</title><link>https://khuencheng.github.io/posts/opensource-contribution/</link><pubDate>Sun, 26 Nov 2023 01:11:34 +0800</pubDate><guid>https://khuencheng.github.io/posts/opensource-contribution/</guid><description>简介 基本流程 挑选项目 工作中接触 日常使用 熟悉项目使用的技术栈 …… 发现问题 代码 拼写 文档 测试 …… fork 修改 代码 测试 注释 文档 签署开源贡献协议 CLA DCO 提交 pull request CI review merge 后续 关闭 issue 等待 release 持续贡献，成为维护者 总体原则 如何成为合</description></item><item><title>Structured concurrency</title><link>https://khuencheng.github.io/posts/structured-concurrency/</link><pubDate>Mon, 01 Aug 2022 23:54:05 +0800</pubDate><guid>https://khuencheng.github.io/posts/structured-concurrency/</guid><description>简介 定义 根据维基百科的解释： Structured concurrency is a programming paradigm aimed at improving the clarity, quality, and development time of a computer program by using a structured approach to concurrent programming. The core concept is the encapsulation of concurrent threads of execution (here encompassing kernel and userland threads and processes) by way of control flow constructs that have clear entry and exit points and that ensure all spawned threads have completed before exit. Such encapsulation allows errors in concurrent threads to be propagated to the control structure&amp;rsquo;s parent scope and</description></item><item><title>Go 1.18 泛型介绍</title><link>https://khuencheng.github.io/posts/go-generics/</link><pubDate>Wed, 16 Mar 2022 22:41:56 +0800</pubDate><guid>https://khuencheng.github.io/posts/go-generics/</guid><description>什么是泛型 泛型程序设计（generic programming）是程序设计语言的一种风格或范式。泛型允许程序员在编写代码时使用一些以后才指定的类型，在实例化时作为参数指明这些类型。 Golang 泛型基本用法 示例 map 操</description></item><item><title>通过 gRPC-Gateway 开发 RESTful API</title><link>https://khuencheng.github.io/posts/go-grpc-gateway/</link><pubDate>Sun, 13 Mar 2022 18:13:14 +0800</pubDate><guid>https://khuencheng.github.io/posts/go-grpc-gateway/</guid><description>gRPC-Gateway 简介 gRPC-Gateway 是 protoc 的一个插件，工作机制是读取一个 gRPC 服务定义并生成一个反向代理服务器，将 RESTful JSON API 翻译成 gRPC。 这个服务器是根据编写的 gRPC 定义中的自定义选项来生成的。 安装使用 依赖工具 工具 简介 安装 protobuf protocol buffer 编译所需的命</description></item><item><title>Python 与 Go 之间的并发模式差异</title><link>https://khuencheng.github.io/posts/concurrency-model-differences-between-python-go/</link><pubDate>Mon, 30 Aug 2021 23:54:05 +0800</pubDate><guid>https://khuencheng.github.io/posts/concurrency-model-differences-between-python-go/</guid><description>Python并发方式 在 Python 中，早期并发方式以传统的多进程和多线程为主，类似 Java，同时，有不少第三方的异步方案（gevent/tornado/twisted 等）。 在 Python 3 时期，官方推出了 asyncio 和 async await 语法，作</description></item><item><title>Distributed Systems for Fun and Profit 笔记（二）</title><link>https://khuencheng.github.io/posts/distributed-systems-for-fun-and-profit-part2/</link><pubDate>Tue, 15 Sep 2020 09:22:15 +0800</pubDate><guid>https://khuencheng.github.io/posts/distributed-systems-for-fun-and-profit-part2/</guid><description>2. 抽象的上下不同层次 系统模型 分布式系统中的程序： 在独立节点上同时运行 通过可能引入不确定性和消息丢失的网络连接 并且没有共享内存或共享时钟 系统模型列举了与特定系统设计相关的许多假设，实现分布式系统的环境和</description></item><item><title>Distributed Systems for Fun and Profit 笔记 （一）</title><link>https://khuencheng.github.io/posts/distributed-systems-for-fun-and-profit-part1/</link><pubDate>Fri, 11 Sep 2020 01:51:32 +0800</pubDate><guid>https://khuencheng.github.io/posts/distributed-systems-for-fun-and-profit-part1/</guid><description>0. 前言 &amp;ldquo;Distributed Systems for Fun and Profit&amp;rdquo; 是 mixu 2013 年在 网络上 免费发布的一本介绍分布式系统的小册子。 分布式的两种结果： 信息以光速传播 独立节点独自失败 分布式系统处理距离和多个节点的问题 1. 从高层次角度看分布式系统 计算机的基本任务 存储</description></item><item><title>编译 CPython 心得</title><link>https://khuencheng.github.io/posts/python-build/</link><pubDate>Fri, 24 Jul 2020 01:11:34 +0800</pubDate><guid>https://khuencheng.github.io/posts/python-build/</guid><description>什么情况下需要自己编译 CPython 大多数操作系统都提供了编译好的 CPython 版本，一般直接通过包管理器安装就能满足需求，但是某些情况下，就需要自己编译 CPython 来满足特定需求了： 操作系统提供的 Python 版本太低，并且 Python 官网、系统包管理源</description></item><item><title>关于</title><link>https://khuencheng.github.io/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://khuencheng.github.io/about/</guid><description>后端研发工程师，从互联网券商到网络安全平台方向，对前后端开发、金融、网络安全等领域有浓厚兴趣。</description></item></channel></rss>