<!doctype html><html lang=zh><head><title>Python 与 Go 之间的并发模式差异 :: Jack Cheng 的个人博客</title>
<meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Python并发方式 在 Python 中，早期并发方式以传统的多进程和多线程为主，类似 Java，同时，有不少第三方的异步方案（gevent/tornado/twisted 等）。 在 Python 3 时期，官方推出了 asyncio 和 async await 语法，作"><meta name=keywords content="[Hugo Programming]"><meta name=robots content="noodp"><link rel=canonical href=https://khuencheng.github.io/posts/concurrency-model-differences-between-python-go/><link rel=stylesheet href=https://khuencheng.github.io/assets/style.css><link rel=stylesheet href=assets/%25!s%28%3cnil%3e%29.css><link rel=apple-touch-icon href=https://khuencheng.github.io/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=https://khuencheng.github.io/img/favicon/orange.png><meta name=twitter:card content="summary"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="og:title" content="Python 与 Go 之间的并发模式差异"><meta property="og:description" content="Python并发方式 在 Python 中，早期并发方式以传统的多进程和多线程为主，类似 Java，同时，有不少第三方的异步方案（gevent/tornado/twisted 等）。 在 Python 3 时期，官方推出了 asyncio 和 async await 语法，作"><meta property="og:url" content="https://khuencheng.github.io/posts/concurrency-model-differences-between-python-go/"><meta property="og:site_name" content="Jack Cheng 的个人博客"><meta property="og:image" content="img/favicon/%!s(<nil>).png"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:section" content="编程"><meta property="article:published_time" content="2021-08-30 23:54:05 +0800 +0800"></head><body><div class="container headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=https://khuencheng.github.io/><div class=logo>Terminal</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/>Home</a></li><li><a href=/posts/>Archive</a></li><li><a href=/tags/>Tags</a></li><li><a href=/categories/>Categories</a></li><li><a href=/about/>About</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/>Home</a></li><li><a href=/posts/>Archive</a></li><li><a href=/tags/>Tags</a></li><li><a href=/categories/>Categories</a></li><li><a href=/about/>About</a></li></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=https://khuencheng.github.io/posts/concurrency-model-differences-between-python-go/>Python 与 Go 之间的并发模式差异</a></h1><div class=post-meta><span class=post-date>2021-08-30</span></div><span class=post-tags>#<a href=https://khuencheng.github.io/tags/python/>Python</a>&nbsp;
#<a href=https://khuencheng.github.io/tags/golang/>Golang</a>&nbsp;
#<a href=https://khuencheng.github.io/tags/concurrency/>Concurrency</a>&nbsp;</span><div class=table-of-contents><h2>Table of Contents</h2><nav id=TableOfContents><ul><li><a href=#python并发方式>Python并发方式</a><ul><li><a href=#进程>进程</a></li><li><a href=#线程>线程</a></li><li><a href=#协程>协程</a></li></ul></li><li><a href=#go-并发方式>Go 并发方式</a><ul><li></li></ul></li><li><a href=#对比>对比</a><ul><li><a href=#有栈协程与无栈协程>有栈协程与无栈协程</a></li><li><a href=#单线程与多线程>单线程与多线程</a></li></ul></li></ul></nav></div><div class=post-content><div><h2 id=python并发方式>Python并发方式<a href=#python并发方式 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>在 Python 中，早期并发方式以传统的多进程和多线程为主，类似 Java，同时，有不少第三方的异步方案（gevent/tornado/twisted 等）。<br>在 Python 3 时期，官方推出了 asyncio 和 async await 语法，作为 Python 官方的协程实现，而逐渐普及。</p><h3 id=进程>进程<a href=#进程 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>多进程编程示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>multiprocessing</span> <span class=kn>import</span> <span class=n>Process</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>f</span><span class=p>(</span><span class=n>name</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;hello&#39;</span><span class=p>,</span> <span class=n>name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s1>&#39;__main__&#39;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span> <span class=o>=</span> <span class=n>Process</span><span class=p>(</span><span class=n>target</span><span class=o>=</span><span class=n>f</span><span class=p>,</span> <span class=n>args</span><span class=o>=</span><span class=p>(</span><span class=s1>&#39;bob&#39;</span><span class=p>,))</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>.</span><span class=n>join</span><span class=p>()</span>
</span></span></code></pre></div><p>multiprocessing 与 threading 的 API 接近，比较容易创建多进程的程序，是 Python 官方推荐作为绕过多线程 GIL 限制的一种方案。<br>但需要注意，创建进程的参数需要能被 pickle 序列化，最好使用 Pipe、Queue 等进程安全的数据结构（<a href=https://docs.python.org/3/library/multiprocessing.html#programming-guidelines>官方文档的 Programming guidelines</a>）</p><h3 id=线程>线程<a href=#线程 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>多线程代码示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>threading</span> <span class=kn>import</span> <span class=n>Thread</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>f</span><span class=p>(</span><span class=n>name</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;hello&#39;</span><span class=p>,</span> <span class=n>name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s1>&#39;__main__&#39;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span> <span class=o>=</span> <span class=n>Thread</span><span class=p>(</span><span class=n>target</span><span class=o>=</span><span class=n>f</span><span class=p>,</span> <span class=n>args</span><span class=o>=</span><span class=p>(</span><span class=s1>&#39;bob&#39;</span><span class=p>,))</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>.</span><span class=n>join</span><span class=p>()</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 线程池方式</span>
</span></span><span class=line><span class=cl><span class=k>with</span> <span class=n>ThreadPoolExecutor</span><span class=p>(</span><span class=n>max_workers</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span> <span class=k>as</span> <span class=n>executor</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>future</span> <span class=o>=</span> <span class=n>executor</span><span class=o>.</span><span class=n>submit</span><span class=p>(</span><span class=nb>pow</span><span class=p>,</span> <span class=mi>323</span><span class=p>,</span> <span class=mi>1235</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>future</span><span class=o>.</span><span class=n>result</span><span class=p>())</span>
</span></span></code></pre></div><p>Cpython 线程的缺陷：GIL（全局解释器锁）<br>GIL 是 Cpython 执行 Python 字节码时的一把全局锁，导致解释器在 CPU 密集型任务时不能充分利用多核，而 IO 密集型任务会释放 GIL。<br>如果想绕过 GIL，只能换成多进程方式，或者通过C 扩展绕过。</p><h3 id=协程>协程<a href=#协程 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>asyncio示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>asyncio</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>time</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>say_after</span><span class=p>(</span><span class=n>delay</span><span class=p>,</span> <span class=n>what</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>await</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=n>delay</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>what</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>main</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;started at </span><span class=si>{</span><span class=n>time</span><span class=o>.</span><span class=n>strftime</span><span class=p>(</span><span class=s1>&#39;</span><span class=si>%X</span><span class=s1>&#39;</span><span class=p>)</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>await</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>gather</span><span class=p>(</span><span class=n>say_after</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=s1>&#39;hello&#39;</span><span class=p>),</span> <span class=n>say_after</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span><span class=s1>&#39;world&#39;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;finished at </span><span class=si>{</span><span class=n>time</span><span class=o>.</span><span class=n>strftime</span><span class=p>(</span><span class=s1>&#39;</span><span class=si>%X</span><span class=s1>&#39;</span><span class=p>)</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=c1># started at 22:32:23</span>
</span></span><span class=line><span class=cl><span class=c1># hello</span>
</span></span><span class=line><span class=cl><span class=c1># world</span>
</span></span><span class=line><span class=cl><span class=c1># finished at 22:32:25</span>
</span></span></code></pre></div><h4 id=async-语法-与-asyncio>async 语法 与 asyncio<a href=#async-语法-与-asyncio class=hanchor arialabel=Anchor>&#8983;</a></h4><p>Python 从 3.4 版本开始，标准库自带 asyncio 模块，并从 3.5 开始，支持 async/await 语法。<br>Python 协程的实现可以追溯到 Python 2 时期引入的 yield 关键字和生成器这种特殊结构：</p><ul><li>生成器通过 yield 暂停，并且可以返回值</li><li>调用方通过 next() 或者 send() 方法恢复生成器的运行，并且可以通过 send() 发送数据给生成器</li><li>yield from 语法糖可以方便的迭代生成器中每一个值</li><li>通过引入 async/await 语法，正式确立协程类型</li><li>asyncio 库提供了官方的事件循环实现，并且支持不同操作系统的 io 多路复用（select/epoll/iocp 等），或者可以通过配置替换为第三方实现（如 uvloop）</li><li>借助 concurrent.futures 线程池/进程池 模块，支持多线程/多进程，但事件循环本身依旧是单线程模式</li></ul><h2 id=go-并发方式>Go 并发方式<a href=#go-并发方式 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>goroutine 与 channel 示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=nx>messages</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>string</span><span class=p>)</span>
</span></span><span class=line><span class=cl>   <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span> <span class=nx>messages</span> <span class=o>&lt;-</span> <span class=s>&#34;ping&#34;</span> <span class=p>}()</span>
</span></span><span class=line><span class=cl>   <span class=nx>msg</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>messages</span>
</span></span><span class=line><span class=cl>   <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>msg</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=goroutine-与-channel>goroutine 与 channel<a href=#goroutine-与-channel class=hanchor arialabel=Anchor>&#8983;</a></h4><p>Golang 实现了用户态的协程 goroutine，通过<a href=https://golang.org/src/runtime/runtime2.go>GPM模型</a>来进行协程的调度，
<img src=https://miro.medium.com/max/1302/1*2o9fS2rEJltFYom65wAIyw.jpeg alt><br>并且通过 netpoller 来支持网络的IO多路复用；<br>通过 channel 在不同 goroutine 中进行通信。</p><h5 id=csp>CSP<a href=#csp class=hanchor arialabel=Anchor>&#8983;</a></h5><p><a href=https://en.wikipedia.org/wiki/Communicating_sequential_processes>CSP（通信顺序进程）</a>是一种并发的模型，通过消息传递来进行交互，而不是通过共享变量。</p><h2 id=对比>对比<a href=#对比 class=hanchor arialabel=Anchor>&#8983;</a></h2><h3 id=有栈协程与无栈协程>有栈协程与无栈协程<a href=#有栈协程与无栈协程 class=hanchor arialabel=Anchor>&#8983;</a></h3><h3 id=单线程与多线程>单线程与多线程<a href=#单线程与多线程 class=hanchor arialabel=Anchor>&#8983;</a></h3></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2023 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=https://khuencheng.github.io/assets/main.js></script><script src=https://khuencheng.github.io/assets/prism.js></script></div></body></html>