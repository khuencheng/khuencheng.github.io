<!doctype html><html lang=zh><head><title>Go 1.18 泛型介绍 :: Ceres Cheng 的个人博客</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="什么是泛型 泛型程序设计（generic programming）是程序设计语言的一种风格或范式。泛型允许程序员在编写代码时使用一些以后才指定的类型，在实例化时作为参数指明这些类型。 Golang 泛型基本用法 示例 map 操"><meta name=keywords content="[Hugo Programming]"><meta name=robots content="noodp"><link rel=canonical href=https://CeresCa.github.io/posts/go-generics/><link rel=stylesheet href=https://CeresCa.github.io/assets/style.css><link rel=stylesheet href=assets/%25!s%28%3cnil%3e%29.css><link rel=apple-touch-icon href=https://CeresCa.github.io/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=https://CeresCa.github.io/img/favicon/orange.png><meta name=twitter:card content="summary"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="og:title" content="Go 1.18 泛型介绍"><meta property="og:description" content="什么是泛型 泛型程序设计（generic programming）是程序设计语言的一种风格或范式。泛型允许程序员在编写代码时使用一些以后才指定的类型，在实例化时作为参数指明这些类型。 Golang 泛型基本用法 示例 map 操"><meta property="og:url" content="https://CeresCa.github.io/posts/go-generics/"><meta property="og:site_name" content="Ceres Cheng 的个人博客"><meta property="og:image" content="img/favicon/%!s().png"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:section" content="编程"><meta property="article:published_time" content="2022-03-16 22:41:56 +0800 +0800"></head><body><div class="container headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=https://CeresCa.github.io/><div class=logo>Terminal</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/>Home</a></li><li><a href=/posts/>Archive</a></li><li><a href=/tags/>Tags</a></li><li><a href=/categories/>Categories</a></li><li><a href=/about/>About</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/>Home</a></li><li><a href=/posts/>Archive</a></li><li><a href=/tags/>Tags</a></li><li><a href=/categories/>Categories</a></li><li><a href=/about/>About</a></li></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=https://CeresCa.github.io/posts/go-generics/>Go 1.18 泛型介绍</a></h1><div class=post-meta><span class=post-date>2022-03-16</span></div><span class=post-tags>#<a href=https://CeresCa.github.io/tags/go/>Go</a>&nbsp;
#<a href=https://CeresCa.github.io/tags/generics/>Generics</a>&nbsp;
#<a href=https://CeresCa.github.io/tags/go-1.18/>Go 1.18</a>&nbsp;</span><div class=table-of-contents><h2>Table of Contents</h2><nav id=TableOfContents><ul><li><a href=#什么是泛型>什么是泛型</a></li><li><a href=#golang-泛型基本用法>Golang 泛型基本用法</a><ul><li><a href=#示例>示例</a></li><li><a href=#尝鲜试用>尝鲜试用</a></li></ul></li><li><a href=#golang-类型当前状况与泛型的意义>Golang 类型当前状况与泛型的意义</a><ul><li><a href=#当前>当前</a></li><li><a href=#go-官方泛型意义>Go 官方泛型意义</a></li></ul></li><li><a href=#golang-泛型发展历史>Golang 泛型发展历史</a></li><li><a href=#golang-泛型实现原理>Golang 泛型实现原理</a><ul><li><a href=#他山之石>他山之石</a></li><li><a href=#go>Go</a></li></ul></li><li><a href=#参考资料>参考资料</a></li></ul></nav></div><div class=post-content><div><h2 id=什么是泛型>什么是泛型<a href=#什么是泛型 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>泛型程序设计（generic programming）是程序设计语言的一种风格或范式。泛型允许程序员在编写代码时使用一些以后才指定的类型，在实例化时作为参数指明这些类型。</p><h2 id=golang-泛型基本用法>Golang 泛型基本用法<a href=#golang-泛型基本用法 class=hanchor arialabel=Anchor>&#8983;</a></h2><h3 id=示例>示例<a href=#示例 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>map 操作</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nx>mapFunc</span><span class=p>[</span><span class=nx>T</span> <span class=nx>any</span><span class=p>,</span> <span class=nx>M</span> <span class=nx>any</span><span class=p>](</span><span class=nx>a</span> <span class=p>[]</span><span class=nx>T</span><span class=p>,</span> <span class=nx>f</span> <span class=kd>func</span><span class=p>(</span><span class=nx>T</span><span class=p>)</span> <span class=nx>M</span><span class=p>)</span> <span class=p>[]</span><span class=nx>M</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>n</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=nx>M</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>a</span><span class=p>),</span> <span class=nb>cap</span><span class=p>(</span><span class=nx>a</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>e</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>a</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>n</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nf>f</span><span class=p>(</span><span class=nx>e</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>n</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>vi</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>6</span><span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>vs</span> <span class=o>:=</span> <span class=nf>mapFunc</span><span class=p>(</span><span class=nx>vi</span><span class=p>,</span> <span class=kd>func</span><span class=p>(</span><span class=nx>v</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>string</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=s>&#34;&lt;&#34;</span> <span class=o>+</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprint</span><span class=p>(</span><span class=nx>v</span> <span class=o>*</span> <span class=nx>v</span><span class=p>)</span> <span class=o>+</span> <span class=s>&#34;&gt;&#34;</span>
</span></span><span class=line><span class=cl>	<span class=p>})</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>vs</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>min max 函数</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>ordered</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=err>~</span><span class=kt>int</span> <span class=p>|</span> <span class=err>~</span><span class=kt>int8</span> <span class=p>|</span> <span class=err>~</span><span class=kt>int16</span> <span class=p>|</span> <span class=err>~</span><span class=kt>int32</span> <span class=p>|</span> <span class=err>~</span><span class=kt>int64</span> <span class=p>|</span> <span class=err>~</span><span class=kt>uint</span> <span class=p>|</span> <span class=err>~</span><span class=kt>uint8</span> <span class=p>|</span> <span class=err>~</span><span class=kt>uint16</span> <span class=p>|</span> <span class=err>~</span><span class=kt>uint32</span> <span class=p>|</span> <span class=err>~</span><span class=kt>uint64</span> <span class=p>|</span> <span class=err>~</span><span class=kt>uintptr</span> <span class=p>|</span> <span class=err>~</span><span class=kt>float32</span> <span class=p>|</span> <span class=err>~</span><span class=kt>float64</span> <span class=p>|</span> <span class=err>~</span><span class=kt>string</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nx>max</span><span class=p>[</span><span class=nx>T</span> <span class=nx>ordered</span><span class=p>](</span><span class=nx>a</span> <span class=p>[]</span><span class=nx>T</span><span class=p>)</span> <span class=nx>T</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>m</span> <span class=o>:=</span> <span class=nx>a</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>v</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>a</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>m</span> <span class=p>&lt;</span> <span class=nx>v</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>m</span> <span class=p>=</span> <span class=nx>v</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>m</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nx>min</span><span class=p>[</span><span class=nx>T</span> <span class=nx>ordered</span><span class=p>](</span><span class=nx>a</span> <span class=p>[]</span><span class=nx>T</span><span class=p>)</span> <span class=nx>T</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>m</span> <span class=o>:=</span> <span class=nx>a</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>v</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>a</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>m</span> <span class=p>&gt;</span> <span class=nx>v</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>m</span> <span class=p>=</span> <span class=nx>v</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>m</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>vi</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>6</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>8</span><span class=p>,</span> <span class=mi>9</span><span class=p>,</span> <span class=mi>10</span><span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>result</span> <span class=o>:=</span> <span class=nf>max</span><span class=p>(</span><span class=nx>vi</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>result</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>vii</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;a&#34;</span><span class=p>,</span> <span class=s>&#34;b&#34;</span><span class=p>,</span> <span class=s>&#34;c&#34;</span><span class=p>,</span> <span class=s>&#34;d&#34;</span><span class=p>,</span> <span class=s>&#34;e&#34;</span><span class=p>,</span> <span class=s>&#34;f&#34;</span><span class=p>,</span> <span class=s>&#34;g&#34;</span><span class=p>,</span> <span class=s>&#34;h&#34;</span><span class=p>,</span> <span class=s>&#34;i&#34;</span><span class=p>,</span> <span class=s>&#34;j&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>result2</span> <span class=o>:=</span> <span class=nf>min</span><span class=p>(</span><span class=nx>vii</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>result2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Set</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Package sets implements sets of any comparable type.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kn>package</span> <span class=nx>sets</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Set is a set of values.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>Set</span><span class=p>[</span><span class=nx>T</span> <span class=nx>comparable</span><span class=p>]</span> <span class=kd>map</span><span class=p>[</span><span class=nx>T</span><span class=p>]</span><span class=kd>struct</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Make returns a set of some element type.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nx>Make</span><span class=p>[</span><span class=nx>T</span> <span class=nx>comparable</span><span class=p>]()</span> <span class=nx>Set</span><span class=p>[</span><span class=nx>T</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nb>make</span><span class=p>(</span><span class=nx>Set</span><span class=p>[</span><span class=nx>T</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Add adds v to the set s.
</span></span></span><span class=line><span class=cl><span class=c1>// If v is already in s this has no effect.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=nx>Set</span><span class=p>[</span><span class=nx>T</span><span class=p>])</span> <span class=nf>Add</span><span class=p>(</span><span class=nx>v</span> <span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>s</span><span class=p>[</span><span class=nx>v</span><span class=p>]</span> <span class=p>=</span> <span class=kd>struct</span><span class=p>{}{}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Delete removes v from the set s.
</span></span></span><span class=line><span class=cl><span class=c1>// If v is not in s this has no effect.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=nx>Set</span><span class=p>[</span><span class=nx>T</span><span class=p>])</span> <span class=nf>Delete</span><span class=p>(</span><span class=nx>v</span> <span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nb>delete</span><span class=p>(</span><span class=nx>s</span><span class=p>,</span> <span class=nx>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Contains reports whether v is in s.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=nx>Set</span><span class=p>[</span><span class=nx>T</span><span class=p>])</span> <span class=nf>Contains</span><span class=p>(</span><span class=nx>v</span> <span class=nx>T</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>_</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>s</span><span class=p>[</span><span class=nx>v</span><span class=p>]</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>ok</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Len reports the number of elements in s.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=nx>Set</span><span class=p>[</span><span class=nx>T</span><span class=p>])</span> <span class=nf>Len</span><span class=p>()</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Iterate invokes f on each element of s.
</span></span></span><span class=line><span class=cl><span class=c1>// It&#39;s OK for f to call the Delete method.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=nx>Set</span><span class=p>[</span><span class=nx>T</span><span class=p>])</span> <span class=nf>Iterate</span><span class=p>(</span><span class=nx>f</span> <span class=kd>func</span><span class=p>(</span><span class=nx>T</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>v</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>s</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>f</span><span class=p>(</span><span class=nx>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=尝鲜试用>尝鲜试用<a href=#尝鲜试用 class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li><p>Go2Goplaygroud： <a href=https://go2goplay.golang.org/>The go2go Playground</a></p></li><li><p>Go 1.17 （非最新，不推荐）：</p><p><code>go run -gcflags=-G=3 myproject``/main``.go</code></p></li><li><p>go 1.18 （正式版已发布）</p><p><a href=https://go.dev/doc/go1.18>https://go.dev/doc/go1.18</a></p></li></ul><h2 id=golang-类型当前状况与泛型的意义>Golang 类型当前状况与泛型的意义<a href=#golang-类型当前状况与泛型的意义 class=hanchor arialabel=Anchor>&#8983;</a></h2><h3 id=当前>当前<a href=#当前 class=hanchor arialabel=Anchor>&#8983;</a></h3><h4 id=interface>interface<a href=#interface class=hanchor arialabel=Anchor>&#8983;</a></h4><p>弊端：类型转换、缺乏编译时的约束</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>printStr</span><span class=p>(</span><span class=nx>x</span> <span class=kd>interface</span><span class=p>{})</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>value</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>x</span><span class=p>.(</span><span class=kt>string</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>!</span><span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;It&#39;s not ok for type string&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;The value is &#34;</span><span class=p>,</span> <span class=nx>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nf>printStr</span><span class=p>(</span><span class=mi>123</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// It&#39;s not ok for type string
</span></span></span></code></pre></div><h4 id=为不同类型单独编写>为不同类型单独编写<a href=#为不同类型单独编写 class=hanchor arialabel=Anchor>&#8983;</a></h4><p>弊端：API与代码实现不整洁、工作量大等</p><p>示例：当前标准库的 sort, math 等</p><ul><li><a href=https://pkg.go.dev/sort>https://pkg.go.dev/sort</a></li><li><a href=https://pkg.go.dev/math>https://pkg.go.dev/math</a></li></ul><h4 id=代码生成>代码生成<a href=#代码生成 class=hanchor arialabel=Anchor>&#8983;</a></h4><p>弊端：需学习第三方代码生成工具、go:generate、AST等知识，不通用</p><p>示例：</p><p><a href=https://github.com/cheekybits/genny>https://github.com/cheekybits/genny</a></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>gogenerate</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;github.com/cheekybits/genny/generic&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//go:generate genny -in=$GOFILE -out=gen-$GOFILE gen &#34;KeyType=string,int ValueType=string,int&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>KeyType</span> <span class=nx>generic</span><span class=p>.</span><span class=nx>Type</span>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>ValueType</span> <span class=nx>generic</span><span class=p>.</span><span class=nx>Type</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>KeyTypeValueTypeMap</span> <span class=kd>map</span><span class=p>[</span><span class=nx>KeyType</span><span class=p>]</span><span class=nx>ValueType</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>NewKeyTypeValueTypeMap</span><span class=p>()</span> <span class=kd>map</span><span class=p>[</span><span class=nx>KeyType</span><span class=p>]</span><span class=nx>ValueType</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=nx>KeyType</span><span class=p>]</span><span class=nx>ValueType</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=go-官方泛型意义>Go 官方泛型意义<a href=#go-官方泛型意义 class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>通用操作与类型约束</li><li>函数式编程</li><li>简化标准库和第三方库的实现</li></ul><p>………</p><h2 id=golang-泛型发展历史>Golang 泛型发展历史<a href=#golang-泛型发展历史 class=hanchor arialabel=Anchor>&#8983;</a></h2><table><thead><tr><th style=text-align:left>简述</th><th style=text-align:left>时间</th><th style=text-align:left>作者</th></tr></thead><tbody><tr><td style=text-align:left>[Type Functions]</td><td style=text-align:left>2010 年</td><td style=text-align:left>Ian Lance Taylor</td></tr><tr><td style=text-align:left>Generalized Types</td><td style=text-align:left>2011 年</td><td style=text-align:left>Ian Lance Taylor</td></tr><tr><td style=text-align:left>Generalized Types v2</td><td style=text-align:left>2013 年</td><td style=text-align:left>Ian Lance Taylor</td></tr><tr><td style=text-align:left>Type Parameters</td><td style=text-align:left>2013 年</td><td style=text-align:left>Ian Lance Taylor</td></tr><tr><td style=text-align:left>go:generate</td><td style=text-align:left>2014 年</td><td style=text-align:left>Rob Pike</td></tr><tr><td style=text-align:left>First Class Types</td><td style=text-align:left>2015 年</td><td style=text-align:left>Bryan C.Mills</td></tr><tr><td style=text-align:left>Contracts</td><td style=text-align:left>2018 年</td><td style=text-align:left>Ian Lance Taylor, Robert Griesemer</td></tr><tr><td style=text-align:left><a href=https://go.googlesource.com/proposal/+/master/design/go2draft-contracts.md>Contracts</a></td><td style=text-align:left>2019 年</td><td style=text-align:left>Ian Lance Taylor, Robert Griesemer</td></tr><tr><td style=text-align:left>Redundancy in Contracts(2019)&rsquo;s Design</td><td style=text-align:left>2019 年</td><td style=text-align:left>Ian Lance Taylor, Robert Griesemer</td></tr><tr><td style=text-align:left><a href=https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md>Constrained Type Parameters</a></td><td style=text-align:left>2020 年</td><td style=text-align:left>Ian Lance Taylor, Robert Griesemer</td></tr><tr><td style=text-align:left><a href=https://arxiv.org/pdf/2005.11710.pdf>Featherweight Go</a></td><td style=text-align:left>2020年</td><td style=text-align:left>Ian Lance Taylor, Robert Griesemer</td></tr><tr><td style=text-align:left>合并进 master、发布 Go 1.18、改进标准库 等</td><td style=text-align:left>2021 - 2022 年</td><td style=text-align:left></td></tr></tbody></table><h2 id=golang-泛型实现原理>Golang 泛型实现原理<a href=#golang-泛型实现原理 class=hanchor arialabel=Anchor>&#8983;</a></h2><h3 id=他山之石>他山之石<a href=#他山之石 class=hanchor arialabel=Anchor>&#8983;</a></h3><h4 id=不同语言泛型实现>不同语言泛型实现<a href=#不同语言泛型实现 class=hanchor arialabel=Anchor>&#8983;</a></h4><p><a href=https://en.wikipedia.org/wiki/Object_type_(object-oriented_programming)#Boxing>boxing </a>(装箱) VS <a href=https://en.wikipedia.org/wiki/Monomorphization>monomorphization</a> (单态化)</p><p><a href=https://thume.ca/2019/07/14/a-tour-of-metaprogramming-models-for-generics/><img src=../static/flowchart-2x-16474487455315.png alt=img></a></p><h4 id=泛型的困境>泛型的困境<a href=#泛型的困境 class=hanchor arialabel=Anchor>&#8983;</a></h4><p><a href=https://research.swtch.com/generic>https://research.swtch.com/generic</a></p><ul><li>拖累程序员: 比如 C 语言，增加了程序员的负担，需要曲折的实现，但是不对增加语言的复杂性</li><li>拖累编译器: 比如 C++，增加了编译器的负担，可能会产生很多冗余的代码，重复的代码还需要编译器斟酌删除，编译的文件可能非常大</li><li>拖累执行时间: 比如 Java，将一些装箱成 Object, 进行类型擦除。虽然减少代码冗余、减少空间，但是需要装箱拆箱操作，代码效率低</li></ul><h3 id=go>Go<a href=#go class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Keith H. Randal 的三个方案：</p><p><a href=https://github.com/golang/proposal/blob/master/design/generics-implementation-dictionaries.md>Generics implementation - Dictionaries</a></p><p>编译时实例化字典，字典包含为类型参数实例化的类型信息</p><p><a href=https://github.com/golang/proposal/blob/master/design/generics-implementation-stenciling.md>Generics implementation - Stenciling</a></p><p>模板生成，为每个实例化类型生成一套独立的代码</p><p><a href=https://github.com/golang/proposal/blob/master/design/generics-implementation-gcshape.md>Generics implementation - GC Shape Stenciling</a></p><p>混合实现，shape类型相同的类型，使用字典区分类型的不同行为，</p><p>类型的shape是指它对内存分配器/垃圾回收器呈现的方式，</p><p>包括大小、所需的对齐方式以及类型的哪些部分包含指针</p><h2 id=参考资料>参考资料<a href=#参考资料 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Go 官方和社区资料：</p><p><a href=https://go.dev/doc/go1.18>https://go.dev/doc/go1.18</a></p><p><a href=https://go.dev/doc/tutorial/generics>https://go.dev/doc/tutorial/generics</a></p><p><strong><a href=https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md>https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md</a></strong></p><p><a href=https://go.dev/blog/generics-proposal>https://go.dev/blog/generics-proposal</a></p><p><a href=https://go.dev/blog/generics-next-step>https://go.dev/blog/generics-next-step</a></p><p><a href=https://go.dev/blog/go2draft>https://go.dev/blog/go2draft</a></p><p><a href=https://go.dev/blog/why-generics>https://go.dev/blog/why-generics</a></p><p><a href=https://github.com/golang/proposal/blob/master/design/generics-implementation-dictionaries.md>https://github.com/golang/proposal/blob/master/design/generics-implementation-dictionaries.md</a></p><p><a href=https://github.com/golang/proposal/blob/master/design/generics-implementation-stenciling.md>https://github.com/golang/proposal/blob/master/design/generics-implementation-stenciling.md</a></p><p><a href=https://github.com/golang/proposal/blob/master/design/generics-implementation-gcshape.md>https://github.com/golang/proposal/blob/master/design/generics-implementation-gcshape.md</a></p><p>示例用法、文章分析等：</p><p><a href=https://github.com/mattn/go-generics-example>https://github.com/mattn/go-generics-example</a></p><p><a href=https://colobu.com/2021/08/30/how-is-go-generic-implemented/>https://colobu.com/2021/08/30/how-is-go-generic-implemented/</a></p><p><a href=https://coolshell.cn/articles/21615.html>https://coolshell.cn/articles/21615.html</a></p><p><a href=https://draveness.me/whys-the-design-go-generics/>https://draveness.me/whys-the-design-go-generics/</a></p><p><a href=https://taoshu.in/go/go-generics-design.html>https://taoshu.in/go/go-generics-design.html</a></p><p><a href=https://research.swtch.com/generic>https://research.swtch.com/generic</a></p><p><a href=https://thume.ca/2019/07/14/a-tour-of-metaprogramming-models-for-generics/>https://thume.ca/2019/07/14/a-tour-of-metaprogramming-models-for-generics/</a></p></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2022 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=https://CeresCa.github.io/assets/main.js></script>
<script src=https://CeresCa.github.io/assets/prism.js></script></div></body></html>