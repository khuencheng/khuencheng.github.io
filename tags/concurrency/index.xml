<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Concurrency on zhoukuncheng's Personal Blog</title><link>https://zhoukuncheng.github.io/tags/concurrency/</link><description>Recent content in Concurrency on zhoukuncheng's Personal Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 01 Aug 2022 23:54:05 +0800</lastBuildDate><atom:link href="https://zhoukuncheng.github.io/tags/concurrency/index.xml" rel="self" type="application/rss+xml"/><item><title>Structured concurrency</title><link>https://zhoukuncheng.github.io/posts/structured-concurrency/</link><pubDate>Mon, 01 Aug 2022 23:54:05 +0800</pubDate><guid>https://zhoukuncheng.github.io/posts/structured-concurrency/</guid><description>简介 定义 根据维基百科的解释： Structured concurrency is a programming paradigm aimed at improving the clarity, quality, and development time of a computer program by using a structured approach to concurrent programming. The core concept is the encapsulation of concurrent threads of execution (here encompassing kernel and userland threads and processes) by way of control flow constructs that have clear entry and exit points and that ensure all spawned threads have completed before exit. Such encapsulation allows errors in concurrent threads to be propagated to the control structure&amp;rsquo;s parent scope and managed by the native error handling mechanisms of each particular computer language. It allows control flow to remain readily evident by the structure of the source code despite the presence of concurrency. To be effective, this model must be applied consistently throughout all levels of the program – otherwise concurrent threads may leak out, become orphaned, or fail to have runtime errors correctly propagated. Structured concurrency is analogous to structured programming, which introduced control flow constructs that encapsulated sequential statements and subroutines. 简单来说：结构化并发（Structu</description></item><item><title>Python 与 Go 之间的并发模式差异</title><link>https://zhoukuncheng.github.io/posts/concurrency-model-differences-between-python-go/</link><pubDate>Mon, 30 Aug 2021 23:54:05 +0800</pubDate><guid>https://zhoukuncheng.github.io/posts/concurrency-model-differences-between-python-go/</guid><description>Python并发方式 在 Python 中，早期并发方式以传统的多进程和多线程为主，类似 Java，同时，有不少第三方的异步方案（gevent/tornado/twisted 等）。 在 Python 3 时期，官方推出了 asyncio 和 async await 语法，作为 Python 官方的协程实现，而逐渐普及。 进程 多进程编程示例： from multiprocessing import Process def f(name): print(&amp;#39;hello&amp;#39;, name) if __name__ == &amp;#39;__main__&amp;#39;: p = Process(target=f, args=(&amp;#39;bob&amp;#39;,)) p.start() p.join() multiprocessing 与 threading 的 API 接近，比较容易创建多进程的程序，是 Python 官方推荐作为绕过多线程 GIL 限制的一种方案。 但需要注意，创建进程的参数</description></item></channel></rss>